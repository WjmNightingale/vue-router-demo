# 概述

`v-for`指令在Vue.js中经常用于一组数据选项列表的渲染。

```html
<ul id="app-one">
    <li v-for="(item,index) in items">
        {{item.message}}
    </li>
</ul>
<!-- 也可以用 of 语法来代替 -->
<ul id="app-two">
    <li v-for="(item,index) of items">
        {{item.message}}
    </li>
</ul>
```

## 一个对象的 v-for

demo：

```html
<ul id="app">
    <li v-for="(value,key,index) in object">
        {{index}}--{{key}}:{{value}}
    </li>
</ul>
```

在遍历对象时，是按 `Object.keys()` 的结果遍历，但是不能保证它的结果在不同的 `JavaScript` 引擎下是一致的。

## key的重要性

当 Vue.js 用 `v-for` 正在更新已渲染过的元素列表时，它默认用“就地复用”策略.如果数据项的顺序被改变的话，`vue` 将不会移动`DOM` 元素来匹配数据项的顺序，而是简单地复用此处的每个元素，并且确保它在特定索引下显示已被渲染过的每个元素

这个模式默认是高效的，但是仅仅只适用于 **不依赖子组件状态或临时 DOM 状态** 的列表渲染输出。一旦子组件状态需要变更或者临时DOM状态发生改变，那么可能出现渲染行为不符合预期

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id，一般使用`v-bind`来动态绑定

```html
<div v-for="item in items" v-bind:key="item.id">
    <!-- 内容 -->
</div>
```

key 是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途

## 数组更新检测

Vue包含一组观察数组的变异方法，所以以下数组方法会触发视图更新

* `push()` 方法将一个或多个元素添加到数组的末尾，并返回新数组的长度。
* `pop()`方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
* `unshift()`方法将一个或多个元素添加到数组的开头，并返回新数组的长度。
* `shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
* `splice()`方法通过删除现有元素和/或添加新元素来更改一个数组的内容。
    `splice(start,[,deleteCount[,item[,item2[,...]]]])`,其中`start`--指定修改的开始位置（从0计数）,如果超出了数组的长度，则从数组末尾开始添加内容,如果是负值，则表示从数组末位开始的第几位（从-1计数）,若只使用start参数而不使用`deleteCount`、`item`，如：`array.splice(start)` ，表示删除`[start，end]`的元素。`deleteCount(可选参数)`,如果 `deleteCount` 是 0，则不移除元素。这种情况下，至少应添加一个新元素,如果 `deleteCount` 大于`start` 之后的元素的总数，则从 `start` 后面的元素都将被删除（含第 `start` 位）。`[,item[,item2[,...]]](可选参数)`。要添加进数组的元素,从`start` 位置开始。如果不指定，则 `splice()` 将只删除数组元素。`splice`方法使用`deleteCount`参数来控制是删除还是添加
* `sort()` 方法用就地（ in-place ）的算法对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。一般需要再添加一个比较函数`compareFunction`
* `reverse()` 该方法将数组中元素的位置颠倒。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。

变异方法`mutation method` 顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异`non-mutating method`方法，例如`filter`，`concat`和`slice`。这些不会原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：

```js
example.items = example.items.filter((item) => {
    return item.message.match(/Foo/)
})
```

你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表.幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。

需要注意的是，由于JavaScript限制，Vue不能检测以下变动的数组：

* 当你利用索引直接设置一个项目时，例如：`vm.items[indexOfItem] = newValue`
* 当你修改数组的长度时，例如：`vm.items.length = newLength`

举个例子：

```js
var vm = new Vue({
    data: {
        items: ['a','b','c']
    }
})
vm.items[1] = 'x' // 不是响应式
vm.items.length = 2 // 不是响应式
```

为了解决第一类问题，以下两种都可以实现和`vm.items[indexOfItem] = newValue`相同的效果，同时也可以触发更新状态：

```js
// Vue.set
Vue.set(vm.items,indexOfItem,newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem,1,newValue)
```

你也可以`vm.$set`实例方法，该方法是全局方法`Vue.set`的一个别名

```js
vm.$set(vm.items,indexOfItem,newValue)
```

为了解决第二类问题，你可以使用`splice`

```js
vm.items.splice(newLength)
```

## 对象更改检测注意事项

还是由于`javascript`的限制，Vue不能检测对象属性的添加或删除

```js
var vm = new Vue({
    data: {
        a: 1
    }
})
// `vm.a`现在是响应式的
vm.b = 2
// `vm.b`不是响应式的
```

对于已经创建的实例，Vue不能动态添加到根级别的响应式属性。但是，可以使用`Vue.set(object,key,value)`方法向嵌套对象添加响应式属性，例如对于：

```js
var vm = new Vue({
    data: {
        userProfile: {
            name: `Anika`
        }
    }
})
```

现在添加一个新的`age`属性嵌套到`userProfile`对象：

```js
Vue.set(vm.userProfile,'age',27)
```

还可以使用`vm.$set`实例方法，它只是全局`Vue.set`的别名：

```js
vm.$set(vm.userProfile,'age',27)
```

