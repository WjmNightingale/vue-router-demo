# 概述

组件是Vue.js里面最核心的概念，而动态组件和异步组件的了解也是必不可少的

## 在动态组件上使用 keep-alive

我们在切换组件时曾使用`is`特性

```html
<component v-bind:is="currentTabComponent"></component>
```

当在这些组件之间切换时，你有时会保持这些组件的状态，以避免重复渲染导致性能问题，例如，我们来展开说一说这个多标签页面

我们会注意到，如果用户在界面选择了一篇文章，切换到Archive标签，然后再切换回Posts标签，此时主页面是不再会展示用户之前展示的那篇文章的。这是因为每次切换新标签时，Vue都会创建一个新的“currentTabComponent”实例

重新创建动态组件的行为通常是非常有用的，但是在有些开发场景，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 `<keep-alive>` 元素将其动态组件包裹起来。

```html
<keep-alive>
    <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```

## 异步组件

在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。

为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：

```js
Vue.component('async-example',function(resolve,reject) {
    setTimeout(function() {
        // 向`resolve`回调传递组件定义
        resolve({
            template: `<div> I am async!</div>`
        })
    },1000)
})
```

如你所见，这个工厂函数会收到一个 `resolve` 回调,这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 `reject(reason)` 来表示加载失败。这里的 `setTimeout` 是为了演示用的，如何获取组件取决于你自己。

一个推荐的做法是将异步组件和 `webpack` 的 `code-splitting` 功能一起配合使用：

```js
Vue.component('async-component-example',function(resolve,reject) {
    // 这个特殊的 `require` 语法将会告诉 webpack
    // 动将你的构建代码切割成多个包
    // 这些包会通过 Ajax 请求加载
    require(['./my-async-component'],resolve)
})
```

开发者也可以在工厂函数中返回一个`Promise`，所以把`webpack 2` 和`ES 2015`语法结合在一起：

```js
Vue.component(
    'async-component',
    () => import('./my-async-component')
)
```

当使用局部注册的时候，你也可以直接提供一个返回 `Promise` 的函数：

```js
new Vue({
    // ...
    components: {
        'my-component': () => import('./my-async-component')
    }
})
```

这里的异步组件工厂函数也可以返回一个如下格式的对象：

```js
const AsyncComponent = () => ({
    // 要加载的组件 (应该是一个 `Promise` 对象)
    component: import('./MyComponent.vue'),
    // 异步组件加载时使用的组件
    loading: LoadingComponent,
    // 加载失败时使用的组件
    error: ErrorComponent,
    // 展示加载时组件的延时时间。默认值是 200 (毫秒)
    delay: 200,
    // 如果提供了超时时间且组件加载也超时了，
    // 则使用加载失败时使用的组件。默认值是：`Infinity`
    timeout: 300
})
```

## 边界处理问题

在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。

## 访问根实例

在每个`new Vue`实例的子组件当中，其根实例可以通过`$root`属性进行访问，例如在这个根实例当中：

```js
// Vue 根实例
new Vue({
    data: {
        foo: 1
    },
    computed: {
        bar: function() {
            return 'bar'
        }
    },
    methods: {
        baz: function() {
            this.foo = 2
        }
    }
})
```

所有的子组件都可以将这个实例作为全局的一个`store`实例来访问或者使用

```js
// 获取根组件的数据
this.$root.foo
// 写入根组件的数据
this.$root.foo = 2
// 访问根组件的数据属性
this.$root.bar
// 调用根组件的方法
this.$root.baz()
```

对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 `Vuex` 来管理应用的状态。

## 访问父级组件的实例

和`$root`类似，`$parent`属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以`prop`的方式传入到子组件的方式

## 